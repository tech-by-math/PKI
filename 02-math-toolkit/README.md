# Mathematical Toolkit

> *"Number theory is the queen of mathematics, and cryptography is her crown jewel."* - Adapted from Carl Friedrich Gauss

## Overview

PKI's robust security emerges from a carefully chosen set of mathematical foundations. This section explores the theoretical bedrock upon which PKI's capabilities are built - from number theory to elliptic curves, from discrete logarithms to post-quantum cryptography.

## Core Mathematical Concepts Behind PKI

This section covers the mathematical structures, theorems, and concepts that PKI relies upon. Understanding these foundations helps explain why PKI works the way it does and what theoretical guarantees it provides.

### Mathematical Foundation Map
```
                    PKI's Mathematical Foundation
                              |
        ┌─────────────────────┼─────────────────────┐
        │                     │                     │
   Number Theory        Algebraic Structures    Information Theory
        │                     │                     │
    ┌───┼───┐             ┌───┼───┐             ┌───┼───┐
  Primes Modular        Groups Fields         Hash   Random
  Factorization Arithmetic  Rings             Functions Numbers
```

## Number Theory

### Prime Numbers and Factorization
- **Fundamental Theorem of Arithmetic**: Every integer has a unique prime factorization
- **Primality Testing**: Algorithms to determine if a number is prime (Miller-Rabin, AKS)
- **Integer Factorization Problem**: The computational difficulty underlying RSA security
- **RSA Application**: Security based on difficulty of factoring n = p×q where p,q are large primes

### Modular Arithmetic
- **Congruence Relations**: a ≡ b (mod n) forms equivalence classes
- **Modular Exponentiation**: Efficient computation of a^b mod n using square-and-multiply
- **Chinese Remainder Theorem**: Solving systems of congruences, used in RSA optimization
- **Quadratic Residues**: Mathematical foundation for certain cryptographic protocols

### Discrete Logarithm Problem
- **Definition**: Given g^x ≡ h (mod p), find x
- **Computational Difficulty**: No known efficient classical algorithm for general case
- **DSA Foundation**: Digital Signature Algorithm security based on discrete log difficulty
- **Diffie-Hellman**: Key exchange protocol leveraging discrete log hardness

## Algebraic Structures

### Group Theory
- **Cyclic Groups**: Groups generated by a single element, fundamental to many protocols
- **Group Order**: Size of the group, critical for security parameter selection
- **Subgroups**: Smaller groups within larger ones, affects key space analysis
- **Generator Elements**: Elements that generate the entire group through repeated operation

### Field Theory
- **Finite Fields**: Mathematical structures with finite number of elements
- **Field Operations**: Addition and multiplication with specific algebraic properties
- **Extension Fields**: Larger fields constructed from smaller ones
- **Application**: Elliptic curve cryptography operates over finite fields

### Ring Theory
- **Polynomial Rings**: Fundamental to error-correcting codes and some cryptographic schemes
- **Ideals**: Special subsets of rings with closure properties
- **Quotient Rings**: Factor structures used in algebraic cryptography
- **Applications**: Lattice-based cryptography and post-quantum schemes

## Elliptic Curve Mathematics

### Curve Equations
- **Weierstrass Form**: y² = x³ + ax + b (most common form)
- **Montgomery Form**: By² = x³ + Ax² + x (efficient for certain operations)
- **Edwards Form**: x² + y² = 1 + dx²y² (complete addition formulas)
- **Curve Parameters**: Selection criteria for cryptographic security

### Point Operations
- **Point Addition**: Geometric and algebraic rules for adding points on curves
- **Point Doubling**: Efficient formulas for computing 2P from point P
- **Scalar Multiplication**: Computing kP efficiently using binary methods
- **Neutral Element**: Point at infinity serves as group identity

### Elliptic Curve Discrete Logarithm Problem (ECDLP)
- **Definition**: Given points P and Q = kP, find k
- **Computational Hardness**: Best known attacks have exponential complexity
- **Security Advantage**: Smaller key sizes compared to RSA for equivalent security
- **Implementation**: ECDSA, ECDH protocols based on ECDLP difficulty

## Cryptographic Hash Functions

### Properties and Requirements
- **Deterministic**: Same input always produces same output
- **Fixed Output Size**: Hash length independent of input size
- **Avalanche Effect**: Small input changes cause large output changes
- **One-Way Function**: Computationally infeasible to reverse

### Security Properties
- **Preimage Resistance**: Given h, hard to find x such that hash(x) = h
- **Second Preimage Resistance**: Given x₁, hard to find x₂ ≠ x₁ with hash(x₁) = hash(x₂)
- **Collision Resistance**: Hard to find any x₁, x₂ with hash(x₁) = hash(x₂)
- **Birthday Paradox**: Collision probability analysis and security implications

### Common Hash Functions
- **SHA-2 Family**: SHA-256, SHA-384, SHA-512 widely used in PKI
- **SHA-3 (Keccak)**: Different construction based on sponge function
- **Blake3**: Modern hash function with parallel processing capabilities
- **Security Levels**: Relationship between hash output size and security strength

## Random Number Generation

### Entropy Sources
- **Hardware Entropy**: Physical processes like thermal noise, quantum effects
- **Environmental Entropy**: System events, user interactions, network timing
- **Entropy Estimation**: Measuring randomness quality in source data
- **Entropy Pooling**: Combining multiple sources for better randomness

### Pseudorandom Number Generators (PRNGs)
- **Cryptographically Secure PRNGs**: Suitable for cryptographic key generation
- **Linear Congruential Generators**: Simple but cryptographically weak PRNGs
- **Mersenne Twister**: High-quality PRNG but not cryptographically secure
- **ChaCha20**: Modern stream cipher often used as CSPRNG

### Random Number Testing
- **Statistical Tests**: NIST SP 800-22 test suite for randomness validation
- **Entropy Estimation**: Methods to measure randomness quality
- **Implementation Vulnerabilities**: Common pitfalls in random number generation
- **Deterministic Random Bit Generators (DRBG)**: Standardized cryptographic PRNGs

## Post-Quantum Cryptography

### Lattice-Based Cryptography
- **Lattice Problems**: Learning With Errors (LWE), Short Vector Problem (SVP)
- **NTRU**: Ring-based lattice cryptography with efficient implementation
- **Kyber**: NIST-selected key encapsulation mechanism
- **Dilithium**: NIST-selected digital signature scheme

### Hash-Based Signatures
- **Merkle Signatures**: Tree-based signatures with minimal security assumptions
- **XMSS**: eXtended Merkle Signature Scheme for forward security
- **SPHINCS+**: Stateless hash-based signatures
- **Quantum Security**: Provable security against quantum attacks

### Code-Based Cryptography
- **Error-Correcting Codes**: Mathematical foundation for code-based schemes
- **McEliece Cryptosystem**: Public key encryption based on error correction
- **Syndrome Decoding Problem**: Computational hardness assumption
- **Classic McEliece**: NIST post-quantum candidate

### Multivariate Cryptography
- **Multivariate Polynomial Systems**: Solving systems over finite fields
- **Hidden Field Equations**: Trapdoor construction technique
- **Rainbow**: Multivariate signature scheme
- **Oil and Vinegar**: Construction method for multivariate schemes

## Information Theory

### Entropy and Information Content
- **Shannon Entropy**: H(X) = -Σ P(x) log P(x) measures information content
- **Conditional Entropy**: Information content given partial knowledge
- **Mutual Information**: Shared information between random variables
- **Applications**: Key generation, randomness extraction, security analysis

### Error Correction and Detection
- **Hamming Codes**: Linear error-correcting codes with perfect properties
- **Reed-Solomon Codes**: Powerful codes for burst error correction
- **LDPC Codes**: Low-density parity-check codes with near-optimal performance
- **Cryptographic Applications**: Key reconciliation, secure communication

### Compression and Efficiency
- **Lossless Compression**: Huffman coding, arithmetic coding principles
- **Kolmogorov Complexity**: Theoretical limits of compression
- **Rate-Distortion Theory**: Trade-offs between compression and fidelity
- **PKI Applications**: Certificate compression, efficient storage methods

## Computational Complexity

### Complexity Classes
- **P vs NP**: Fundamental question affecting cryptographic assumptions
- **NP-Complete Problems**: Hardest problems in NP class
- **Average-Case vs Worst-Case**: Different hardness assumptions
- **Random Oracle Model**: Theoretical framework for cryptographic proofs

### Reduction Techniques
- **Polynomial-Time Reductions**: Relating problem difficulties
- **Security Reductions**: Proving cryptographic security based on hard problems
- **Concrete Security**: Quantifying actual attack costs vs theoretical hardness
- **Provable Security**: Formal frameworks for cryptographic analysis

### Quantum Complexity
- **BQP Complexity Class**: Problems efficiently solvable by quantum computers
- **Shor's Algorithm**: Quantum algorithm for integer factorization and discrete logs
- **Grover's Algorithm**: Quadratic speedup for unstructured search
- **Quantum Impact**: How quantum computing affects current cryptography

## Files in This Section

- `number-theory.md` - Primes, factorization, and modular arithmetic
- `elliptic-curves.md` - Curve mathematics and ECDLP
- `algebraic-structures.md` - Groups, rings, and fields in cryptography
- `hash-functions.md` - Cryptographic hash construction and analysis
- `random-numbers.md` - Entropy sources and pseudorandom generation
- `post-quantum.md` - Mathematics of quantum-resistant cryptography
- `information-theory.md` - Entropy, compression, and error correction
- `complexity-theory.md` - Computational hardness and security reductions

## Mathematical Foundations in Practice

### RSA Mathematics
```
Key Generation:
1. Choose large primes p, q
2. Compute n = p × q
3. Compute φ(n) = (p-1)(q-1)
4. Choose e with gcd(e, φ(n)) = 1
5. Compute d with e × d ≡ 1 (mod φ(n))

Public Key: (n, e)
Private Key: (n, d)

Encryption: c = m^e mod n
Decryption: m = c^d mod n
```

### Elliptic Curve Mathematics
```
Curve: y² = x³ + ax + b mod p

Point Addition (P + Q = R):
If P ≠ Q:
  λ = (y₂ - y₁)(x₂ - x₁)⁻¹ mod p
  x₃ = λ² - x₁ - x₂ mod p
  y₃ = λ(x₁ - x₃) - y₁ mod p

Point Doubling (2P = R):
  λ = (3x₁² + a)(2y₁)⁻¹ mod p
  x₃ = λ² - 2x₁ mod p
  y₃ = λ(x₁ - x₃) - y₁ mod p
```

### Digital Signature Mathematics
```
ECDSA Signature Generation:
1. Select random k ∈ [1, n-1]
2. Compute (x₁, y₁) = k × G
3. Compute r = x₁ mod n
4. Compute s = k⁻¹(hash(m) + r × private_key) mod n
5. Signature = (r, s)

ECDSA Signature Verification:
1. Compute w = s⁻¹ mod n
2. Compute u₁ = hash(m) × w mod n
3. Compute u₂ = r × w mod n
4. Compute (x₁, y₁) = u₁ × G + u₂ × public_key
5. Verify r = x₁ mod n
```

## Security Analysis Framework

### Bit Security Levels
```
Security Level    Symmetric Key    RSA Key    ECC Key    Hash Output
80-bit           80 bits          1024 bits   160 bits   160 bits
112-bit          112 bits         2048 bits   224 bits   224 bits
128-bit          128 bits         3072 bits   256 bits   256 bits
192-bit          192 bits         7680 bits   384 bits   384 bits
256-bit          256 bits         15360 bits  512 bits   512 bits
```

### Attack Complexity Estimates
```
Algorithm          Classical Complexity    Quantum Complexity
RSA Factorization  exp(O(n^(1/3)))        O(n³) (Shor)
ECC Discrete Log   O(√n)                  O(n³) (Shor)
Hash Preimage      O(2ⁿ)                  O(2^(n/2)) (Grover)
Hash Collision     O(2^(n/2))             O(2^(n/3)) (BHT)
```

---

**Next**: [Algorithms - RSA, ECDSA, and Certificate Validation](../03-algorithms/README.md) 🔧  
**Previous**: [Core Model - PKI Trust Framework](../01-core-model/README.md) 🏠  
**See Also**: [Experiments](../05-experiments/README.md) for hands-on mathematical demonstrations 🧪